---
type: link
source: notion
url: https://ordep.dev/posts/writing-code-was-never-the-bottleneck
notion_type: Tech Deep Dive
tags: ['Running']
created: 2025-09-04T02:23:00.000Z
---

# Writing Code Was Never The Bottleneck - ordep.dev

## Overview (from Notion)
- The article emphasizes that while tools like LLMs make code writing easier, the real challenges lie in understanding, reviewing, and maintaining that code. This is particularly relevant for you as someone who balances family and a demanding career in tech.
- The notion that faster code generation can lead to less thorough verification could resonate with your experiences managing teams and ensuring quality in a fast-paced environment.
- It highlights the importance of clear communication and collaboration, which might be crucial in your role as a founder, where mentoring and knowledge transfer within your team are vital.
- Unique viewpoint: LLMs might lead to a culture of "copy-paste engineering," which could compromise learning and growth among junior developers—something you might want to address in your leadership style.
- Alternate view: Some might argue that LLMs will eventually reduce the need for extensive understanding, as AI continues to evolve, leading to a shift in how software engineering is perceived and practiced.
- The piece underscores the ongoing need for thoughtful design and careful review—elements that could serve as a foundation for your company's culture and operational values.

## AI Summary (from Notion)
Writing code is not the bottleneck in software engineering; the real challenges lie in code reviews, knowledge transfer, testing, and communication. While LLMs can speed up code generation, they increase the complexity of verification and understanding, leading to potential quality issues. The cost of understanding and maintaining code remains high, emphasizing the need for collaboration, clear thinking, and careful review as code production accelerates.

## Content (from Notion)

For years, I’ve felt that writing lines of code was never the bottleneck in software engineering.

The actual bottlenecks were, and still are, code reviews, knowledge transfer through mentoring and pairing, testing, debugging, and the human overhead of coordination and communication. All of this wrapped inside the labyrinth of tickets, planning meetings, and agile rituals.

These processes, meant to drive quality, often slow us down more than the act of writing code itself because they require thought, shared understanding, and sound judgment.

Now, with LLMs making it easy to generate working code faster than ever, a new narrative has emerged: that writing code was the bottleneck, and we’ve finally cracked it.

But that’s not quite right.

The marginal cost of adding new software is approaching zero, especially with LLMs. But what is the price of understanding, testing, and trusting that code? Higher than ever.

## LLMs shift the workload — they don’t remove it

Tools like Claude can speed up initial implementation. Still, the result is often more code flowing through systems and more pressure on the people responsible for reviewing, integrating, and maintaining it.

This becomes especially clear when:

- It’s unclear whether the author fully understands what they submitted.
- The generated code introduces unfamiliar patterns or breaks established conventions.
- Edge cases and unintended side effects aren’t obvious.
We end up in a situation where code is more straightforward to produce but more complex to verify, which doesn’t necessarily make teams move faster overall.

It’s not a new challenge. Developers have long joked about “copy-paste engineering”, but the velocity and scale that LLMs enable have amplified those copy-paste habits.

## Understanding code is still the hard part

> 

LLMs reduce the time it takes to produce code, but they haven’t changed the amount of effort required to reason about behavior, identify subtle bugs, or ensure long-term maintainability. That work can be even more challenging when reviewers struggle to distinguish between generated and handwritten code or understand why a particular solution was chosen.

Software engineering has always been collaborative. It depends on shared understanding, alignment, and mentoring. However, when code is generated faster than it can be discussed or reviewed, teams risk falling into a mode where quality is assumed rather than ensured. That creates stress on reviewers and mentors, potentially slowing things down in more subtle ways.

There’s real value in faster prototyping, scaffolding, and automation. But LLMs don’t remove the need for clear thinking, careful review, and thoughtful design. If anything, those become even more important as more code gets generated.

Yes, the cost of writing code has indeed dropped. But the cost of making sense of it together as a team hasn’t.

That’s still the bottleneck. Let’s not pretend it isn’t.


